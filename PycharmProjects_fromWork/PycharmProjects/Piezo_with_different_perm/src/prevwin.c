/*
	This file was generated by XVT-Design 4.5, a product of:

		XVT Software Inc.
		4900 Pearl East Circle
		Boulder, CO USA 80301
		303-443-4223, fax 303-443-0969

	Generated on Tue Sep 02 10:34:59 1997
*/
/* TAG BEGIN SPCL:Pre_Header */
/* TAG END SPCL:Pre_Header */

#include "xvt.h"
#include "xvtcm.h"
#include "nodInc.h"

/* 
	Information about the window
*/
#define WIN_RES_ID PREVIEW_WINDOW
#define WIN_FLAGS 0x810L
#define WIN_CLASS ""
#define WIN_BORDER W_PLAIN
/* TAG BEGIN SPCL:Obj_Decl */
extern WINDOW currentPreviewWindow;
#ifdef OPENGL
double xRotate = 30.0, yRotate = 45.0;
PNT point = {0, 0};
int mouseDown = FALSE;
#endif
/* TAG END SPCL:Obj_Decl */

/*
	Handler for window PREVIEW_WINDOW ("Preview")
*/
long XVT_CALLCONV1
#if XVT_CC_PROTO
PREVIEW_WINDOW_eh XVT_CALLCONV2 (WINDOW xdWindow, EVENT *xdEvent)
#else
PREVIEW_WINDOW_eh XVT_CALLCONV2 (xdWindow, xdEvent)
WINDOW xdWindow;
EVENT *xdEvent;
#endif
{
	short xdControlId = xdEvent->v.ctl.id;
	/* TAG BEGIN SPCL:Var_Decl */
	/* TAG END SPCL:Var_Decl */

	switch (xdEvent->type) {
	case E_CREATE:
		/*
			Window has been created; first event sent to newly-created
			window.
		*/
		{
		/* TAG BEGIN EVNT:Create */
#ifdef OPENGL
#if XVTWS == WIN32WS
			HWND hWnd;
			HDC hDC;
			hWnd = (HWND) xvt_vobj_get_attr(xdWindow, ATTR_NATIVE_WINDOW);
			hDC = GetDC(hWnd);
			OnCreate(hDC);
#else
			Widget hWnd;
			Display *dpy = NULL;
			XVisualInfo *hDC = NULL;
			int doubleBuffer = TRUE;
			int configuration[] = {GLX_DOUBLEBUFFER, GLX_RGBA, GLX_DEPTH_SIZE, 16, None};
		
			hWnd = (Widget) xvt_vobj_get_attr(xdWindow, ATTR_X_WIDGET);
			if (hWnd == NULL)
				xvt_dm_post_error("Could not get X widget for the XVT window");
		
			dpy = (Display *) xvt_vobj_get_attr(xdWindow, ATTR_X_DISPLAY);
		
			if (!glXQueryExtension(dpy, NULL, NULL))
				xvt_dm_post_error("X server has no OpenGL GLX extension");
		
			if (doubleBuffer)
				hDC = glXChooseVisual(dpy, DefaultScreen(dpy), configuration);
			if (hDC == NULL)
			{
				hDC = glXChooseVisual(dpy, DefaultScreen(dpy), &configuration[1]);
				if (hDC == NULL)
					xvt_dm_post_error("no appropriate RGB visual with depth buffer");
				doubleBuffer = GL_FALSE;
			}
		
			createGLwidget(hWnd);
#endif
#endif
		/* TAG END EVNT:Create */
		}
		break;
	case E_DESTROY:
		/*
			Window has been closed; last event sent to window.
		*/
		xdRemoveHelpAssoc( xdWindow );
		{
		/* TAG BEGIN EVNT:Destroy */
		if (currentPreviewWindow == xdWindow)
		   currentPreviewWindow = NULL_WIN;
		/* TAG END EVNT:Destroy */
		}
		break;
	case E_FOCUS:
		{
		/* TAG BEGIN EVNT:Focus */
		/*
			Window has lost or gained focus.
		*/
		if (xdEvent->v.active) {
			/*
				Window has gained focus
			*/
		} else {
			/*
				Window has lost focus
			*/
		}
		/* TAG END EVNT:Focus */
		}
		break;
	case E_SIZE:
		/*
			Size of window has been set or changed; sent when window is
			created or subsequently resized by user or via xvt_vobj_move.
		*/
		{
		/* TAG BEGIN EVNT:Size */
#ifdef OPENGL
			RCT rect;
			xvt_vobj_get_client_rect (xdWindow, &rect);
			OnSize((int) xvt_rect_get_width(&rect), (int) xvt_rect_get_height(&rect));
#endif
		/* TAG END EVNT:Size */
		}
		break;
	case E_UPDATE:
		/*
			Window requires updating.
		*/
		{
		/* TAG BEGIN EVNT:Update */
#ifdef OPENGL
#if XVTWS == WIN32WS
		RenderScene(xRotate, yRotate);
#else
		extern void draw_scene_callback();
		extern Widget glWidget;
		
		draw_scene_callback ((Widget) glWidget, (caddr_t) 0, (caddr_t) 0);
#endif
#else
		long data;
		data = xvt_vobj_get_data(xvt_vobj_get_parent(xdWindow));
		if (xdWindow == (WINDOW) data)
		   update3dPreview (xdWindow, (OBJECT *) NULL);
		else
		   update3dPreview (xdWindow, (OBJECT *) data);
#endif
		/* TAG END EVNT:Update */
		}
		break;
	case E_CLOSE:
		/*
			Request to close window; user operated "close" menu item on
			window system menu, or operated "close" control on window
			frame. Not sent if Close on File menu is issued. Window not
			closed unless xvt_vobj_destroy is called.
		*/
		{
		/* TAG BEGIN EVNT:Close */
		xvt_vobj_destroy(xdWindow);
		/* TAG END EVNT:Close */
		}
		break;
	case E_CHAR:
		/*
			Character typed.
		*/
		{
		/* TAG BEGIN EVNT:Char */
			/* *********************************************** */
			/* make a RETURN key activate the window OK Button */
		if (xdEvent->v.chr.ch == '\r')
		{                              /* Pass the event down the window heirachy */
		   xvt_win_dispatch_event (xvt_vobj_get_parent(xdWindow), xdEvent);
		}
		/* TAG END EVNT:Char */
		}
		break;
	case E_MOUSE_UP:
		/*
			Mouse was released
		*/
		{
		/* TAG BEGIN EVNT:Mouse_Up */
#ifdef OPENGL
		mouseDown = FALSE;
#endif
		if (xdEvent->v.mouse.button == 0)
		   xvt_dwin_invalidate_rect (xdWindow, (RCT *) NULL);
		/* TAG END EVNT:Mouse_Up */
		}
		break;
	case E_MOUSE_DOWN:
		/*
			Mouse was pressed
		*/
		{
		/* TAG BEGIN EVNT:Mouse_Down */
#ifdef OPENGL
		point = xdEvent->v.mouse.where;
		mouseDown = TRUE;
#else
/*
		if (xdEvent->v.mouse.button != 0)
			createParamEditWindow ( (int) 1 );
*/
		/*
		WINDOW menuWindow;
		if (xdEvent->v.mouse.button != 0)
		{
		   menuWindow = createPopupWindow (xdWindow, xdEvent->v.mouse.where,
		                             PREVIEW_MENU_WINDOW, PREVIEW_MENU_WINDOW_eh,
		                             (long) xdWindow);
		}
		*/
#endif
		/* TAG END EVNT:Mouse_Down */
		}
		break;
	case E_MOUSE_DBL:
		/*
			Mouse was double clicked
		*/
		{
		/* TAG BEGIN EVNT:Mouse_Dbl */
		
		/* TAG END EVNT:Mouse_Dbl */
		}
		break;
	case E_MOUSE_MOVE:
		/*
			Mouse was moved
		*/
		{
		/* TAG BEGIN EVNT:Mouse_Move */
#ifdef OPENGL
			if (mouseDown)
			{
				PNT diff;
				diff.h = xdEvent->v.mouse.where.h - point.h;
				diff.v = xdEvent->v.mouse.where.v - point.v;
				xRotate += diff.v;
				yRotate += diff.h;
				point = xdEvent->v.mouse.where;
				xvt_dwin_invalidate_rect (xdWindow, NULL);
			}
#endif
		/* TAG END EVNT:Mouse_Move */
		}
		break;
	case E_HSCROLL:
		{
		/* TAG BEGIN EVNT:Hscroll */
		/*
			Horizontal scrollbar on frame was operated
		*/
		switch (xdEvent->v.scroll.what) {
		case SC_LINE_UP:
			break;
		case SC_LINE_DOWN:
			break;
		case SC_PAGE_UP:
			break;
		case SC_PAGE_DOWN:
			break;
		case SC_THUMB:
			break;
		case SC_THUMBTRACK:
			break;
		default:
			break;
		}
		/* TAG END EVNT:Hscroll */
		}
		break;
	case E_VSCROLL:
		{
		/* TAG BEGIN EVNT:Vscroll */
		/*
			Vertical scrollbar on frame was operated
		*/
		switch (xdEvent->v.scroll.what) {
		case SC_LINE_UP:
			break;
		case SC_LINE_DOWN:
			break;
		case SC_PAGE_UP:
			break;
		case SC_PAGE_DOWN:
			break;
		case SC_THUMB:
			break;
		case SC_THUMBTRACK:
			break;
		default:
			break;
		}
		/* TAG END EVNT:Vscroll */
		}
		break;
	case E_COMMAND:
		/*
			User issued command on window menu bar (menu bar at top of
			screen for Mac/CH).
		*/
		{
		/* TAG BEGIN EVNT:Command */
		/*
			No menubar was associated with this window
		*/
		/* TAG END EVNT:Command */
		}
		break;
	case E_CONTROL:
		/*
			User operated control in window.
		*/
		{
		/* TAG BEGIN SPCL:Control_Decl */
		/* TAG END SPCL:Control_Decl */

		switch(xdControlId) {
		case PREVIEW_TYPE_OPTIONS: /* "Prevew Type Options" */
			{
			/* TAG BEGIN PREVIEW_TYPE_OPTIONS EVNT:Control */
			xvt_dwin_invalidate_rect (xdWindow, (RCT *) NULL);
			/* TAG END PREVIEW_TYPE_OPTIONS EVNT:Control */
			}
			break;
		case PREVIEW_TYPE: /* "Preview Type" */
			{
			/* TAG BEGIN PREVIEW_TYPE EVNT:Control */
			WINDOW previewTypeOptionsWin;
			int previewType;
			previewTypeOptionsWin = xvt_win_get_ctl(xdWindow, PREVIEW_TYPE_OPTIONS);
			previewType = xvt_list_get_sel_index(xvt_win_get_ctl(xdWindow, PREVIEW_TYPE));
			switch (previewType)
			{
			   case (0):  /* plane */
			      xvt_vobj_set_visible(previewTypeOptionsWin, FALSE);
			      break;
			   case (1):  /* Block */
			      xvt_vobj_set_visible(previewTypeOptionsWin, TRUE);
			      break;
			   case (2):  /* Gravity */
			      xvt_vobj_set_visible(previewTypeOptionsWin, TRUE);
			      break;
			   case (3):  /* Magnetic */
			      xvt_vobj_set_visible(previewTypeOptionsWin, TRUE);
			      break;
			   case (4):  /* Gravity */
			      xvt_vobj_set_visible(previewTypeOptionsWin, TRUE);
			      break;
			   case (5):  /* Magnetic */
			      xvt_vobj_set_visible(previewTypeOptionsWin, TRUE);
			      break;
			   case (6):  /* Gravity */
			      xvt_vobj_set_visible(previewTypeOptionsWin, TRUE);
			      break;
			   case (7):  /* Magnetic */
			      xvt_vobj_set_visible(previewTypeOptionsWin, TRUE);
			      break;
			   default:
			      xvt_vobj_set_visible(previewTypeOptionsWin, TRUE);
			}
			xvt_dwin_invalidate_rect (xdWindow, (RCT *) NULL);
			/* TAG END PREVIEW_TYPE EVNT:Control */
			}
			break;
		case PREVIEW_UPDATE: /* "Update" */
			{
			/* TAG BEGIN PREVIEW_UPDATE EVNT:Control */
			WINDOW ctl_win = xvt_win_get_ctl(xdWindow, PREVIEW_UPDATE);
			int checked = !xvt_ctl_is_checked (ctl_win);
			xvt_ctl_set_checked(ctl_win, (BOOLEAN) checked);
			if (checked)
			   xvt_dwin_invalidate_rect (xdWindow, (RCT *) NULL);
			/* TAG END PREVIEW_UPDATE EVNT:Control */
			}
			break;
		default:
			break;
		}
		}
		break;
	case E_FONT:
		/*
			User issued font command on window menu bar (menu bar at top of
			screen for Mac/CH).
		*/
		{
		/* TAG BEGIN EVNT:Font */
		/* TAG END EVNT:Font */
		}
		break;
	case E_TIMER:
		/*
			Timer associated with window went off.
		*/
		{
		/* TAG BEGIN EVNT:Timer */
		/* TAG END EVNT:Timer */
		}
		break;
	case E_USER:
		/*
			Application initiated.
		*/
		{
		/* TAG BEGIN EVNT:User */
		switch (xdEvent->v.user.id) {
		case -1:
		default:
			break;
		}
		/* TAG END EVNT:User */
		}
		break;
	default:
		break;
	}
	/* TAG BEGIN SPCL:Bottom */
	xvt_tx_process_event(xdWindow, xdEvent);
	/* TAG END SPCL:Bottom */
	return 0L;
}
