/*
	This file was generated by XVT-Design 4.5, a product of:

		XVT Software Inc.
		4900 Pearl East Circle
		Boulder, CO USA 80301
		303-443-4223, fax 303-443-0969

	Generated on Tue Sep 02 10:34:59 1997
*/
/* TAG BEGIN SPCL:Pre_Header */
/* TAG END SPCL:Pre_Header */

#include "xvt.h"
#include "xvtcm.h"
#include "nodInc.h"

static long XVT_CALLCONV1
task_eh XVT_CALLCONV2 XVT_CC_ARGS((WINDOW xdWindow, EVENT *xdEvent));


#define xd_BLOCK_SIZE	50L

typedef struct
{
	WINDOW  container;
	long  obj_id;
	long  topic_id;
	xd_OBJ_TYPE  obj_type;
} xd_HELP_ASSOC;

static void xdInitHelp XVT_CC_ARGS(( void ));
static void xdCleanupHelp XVT_CC_ARGS(( void ));
static void xdOpenHelp XVT_CC_ARGS(( void ));

static XVT_HELP_INFO xd_help_info = (XVT_HELP_INFO) 0;
static xd_HELP_ASSOC*  xd_temp_assoc_list = (xd_HELP_ASSOC *) 0;
static long  xd_next_slot = -1L;
static long  xd_list_size = 0L;
static PNT xdSrcCharSize = {16,8};
/* TAG BEGIN SPCL:Obj_Decl */

extern char *commandLine;

extern DIRECTORY defaultDir;

#if XVTWS == MACWS
DATA_PTR XVT_CALLCONV1 my_alloc (size_t size)
{
   return NewPtr(size);
}

void XVT_CALLCONV1 my_free (DATA_PTR data)
{
   DisposPtr (data);
}

DATA_PTR XVT_CALLCONV1 my_realloc (DATA_PTR oldData, size_t newSize)
{
   DATA_PTR newData;

   newData = NewPtr(newSize);
   return memcpy (newData, oldData, GetPtrSize(oldData));
   DisposPtr (oldData);
}

DATA_PTR XVT_CALLCONV1 my_zmalloc (size_t size)
{
   return NewPtrClear (size);
}

XVT_MEM my_functions = { my_alloc, my_free, my_realloc, my_zmalloc };

#endif
/* TAG END SPCL:Obj_Decl */

XVT_CONFIG xvt_config = {
	TASK_MENUBAR, /* task window menu bar ResID */
	DLG_126, /* default aboutbox ResID */
	"noddy", /* application's "file name" */
	"Noddy", /* application's name */
	"Noddy" /* title for task window */
};

int XVT_CALLCONV1
#if XVT_CC_PROTO
main_old XVT_CALLCONV2 (int argc, char *argv[])
#else
main_old XVT_CALLCONV2 (argc, argv)
int argc;
char *argv[];
#endif
{
xvtcm_set_src_char_size(xdSrcCharSize);

#ifdef XVT_R40_TXEDIT_BEHAVIOR
	xvt_vobj_set_attr(NULL_WIN, ATTR_R40_TXEDIT_BEHAVIOR, (long)TRUE);
#endif
	/* TAG BEGIN SPCL:Main_Code */
#if (XVTWS == MTFWS)
		xvt_vobj_set_attr (NULL_WIN, ATTR_X_PLACE_WINDOW_EXACT, (long)TRUE);
#endif
#if (XVTWS == XOLWS)
		xvt_vobj_set_attr (NULL_WIN, ATTR_X_PLACE_WINDOW_EXACT, (long)TRUE);
#endif
#if XVTWS == MACWS
	/*	xvt_vobj_set_attr (NULL_WIN, ATTR_MEMORY_MANAGER, (long) &my_functions); */
		xvt_vobj_set_attr (NULL_WIN, ATTR_MAC_NO_SELECT_WINDOW, (long) TRUE);
#endif
	
	xvt_fsys_get_default_dir (&defaultDir);
	
	if ( (argc > 2) ||
	    ((argc > 1) && ((argv[1][0] == '-') &&
	                    ((argv[1][1] == 'h') ||
	                     (argv[1][1] == '?')))))
	{
	   int interactive = FALSE, arg;
	
	   /* Just check though the arguments and see if a font is specified */
	   for (arg = 0; arg < argc; arg++)
	      if ((strcmp(argv[arg], "-fn") == 0) || (strcmp(argv[arg], "-font") == 0))
	         interactive = TRUE;
	
	   if (!interactive)
	   {
	      batchNoddy (argc, argv);
	      return (0);
	   }
	}

	if (argc > 1) 
		commandLine = argv[1];
	else
		commandLine = 0;

   xvt_app_create(1/*argc*/, argv, 0L, task_eh, &xvt_config);
	return (0);
	/* TAG END SPCL:Main_Code */
}

static long XVT_CALLCONV1
#if XVT_CC_PROTO
task_eh XVT_CALLCONV2 (WINDOW xdWindow, EVENT *xdEvent)
#else
task_eh XVT_CALLCONV2 (xdWindow, xdEvent)
WINDOW xdWindow;
EVENT *xdEvent;
#endif
{
	/* TAG BEGIN SPCL:Var_Decl */
	/* TAG END SPCL:Var_Decl */

	switch (xdEvent->type) {
	case E_CREATE:
/*
     only enable menu items on the task menubar
     if there is a task window with a menubar
*/
#if (XVTWS == WIN16WS || XVTWS == PMWS || XVTWS == WIN32WS)
          if (!xvt_vobj_get_attr( NULL_WIN, ATTR_WIN_PM_NO_TWIN )) {
#endif
#if (XVTWS == WIN16WS || XVTWS == PMWS || XVTWS == WIN32WS)
         }
#endif
		xdInitHelp();
		{
		/* TAG BEGIN EVNT:Create */
		int width, height;
		RCT position;
		WINDOW builderWin;
		/*
#if XVTWS == MACWS
		long free_mem;
		long grow_mem;
		char *the_lot;
#endif
		*/
		XVT_PALETTE winPalette;
		NODDY_COLOUR *colors;
		int numColors, color;
		COLOR theColor;
		
		if (colors = (NODDY_COLOUR *) getPredefinedColors (&numColors))
		{
		   if (winPalette = xvt_palet_create(XVT_PALETTE_USER, NULL))
		   {
		      xvt_palet_set_tolerance(winPalette, 0L);
		      for (color = 0; color < numColors; color++)
		      {
		         theColor = XVT_MAKE_COLOR(colors[color].red, colors[color].green, colors[color].blue);
		         xvt_palet_add_colors(winPalette, &theColor, (short) 1);
		      }
		      if (colors = (NODDY_COLOUR *) getCustomColors (&numColors))
		      {
		         for (color = 0; color < numColors; color++)
		         {
		            theColor = XVT_MAKE_COLOR(colors[color].red, colors[color].green, colors[color].blue);
		            xvt_palet_add_colors(winPalette, &theColor, (short) 1);
		         }
		      }
		      xvt_vobj_set_palet(TASK_WIN, winPalette);
		      xvt_palet_destroy(winPalette);
		   }
		}
		
		if (checkLicence())
		{
			width = (int) xvt_vobj_get_attr (NULL_WIN, ATTR_SCREEN_WIDTH);
			height = (int) xvt_vobj_get_attr (NULL_WIN, ATTR_SCREEN_HEIGHT);
		                if (!getWindowStartPosition ("History", &position.left, &position.top, &position.right, &position.bottom, NULL, NULL))
		                {
		                   position.left = width/4;
		                   position.top = height/4;
		                   position.right = position.left + width/2;
		                   position.bottom = position.top + height/2;
		                }
			builderWin = xvt_win_create (W_DOC, &position,
			                            " Noddy ", TASK_MENUBAR,
		                    	        TASK_WIN, WSF_DECORATED | WSF_ICONIZABLE,
				        EM_ALL, windowEventHandler, 0L);
			xvt_errmsg_sig_if(!(builderWin != NULL_WIN), NULL_WIN, SEV_FATAL, ERR_ASSERT_4,"106",
					106, "Cannot create Main Window");
		}
		else
		{
			WINDOW licWin;
			licWin = createPositionedWindow (LICENCE_WINDOW, TASK_WIN, 10, 10,
					EM_ALL, LICENCE_WINDOW_eh, 0L, (RCT *) NULL);
			xvt_vobj_set_visible (licWin, TRUE);
		}
#if XVTWS == MACWS 
		         /* grab and free mac memory to get around freeing problems later */
		/*
		free_mem = MaxMem(&grow_mem);
		the_lot = malloc ((size_t) free_mem*0.9);
		free(the_lot);
		*/
#endif
		/* TAG END EVNT:Create */
		}
		break;
	case E_DESTROY:
		/*
			Application is being terminated; last event sent to application.
		*/
		xdCleanupHelp();
		{
		/* TAG BEGIN EVNT:Destroy */
		/* TAG END EVNT:Destroy */
		}
		break;
	case E_SIZE:
		/*
			Size of task window has been set or changed. Always sent
			on application startup; may be sent subsequently if
			physical task window (Win/PM) is resized by user or via
			xvt_vobj_move.
		*/
		{
		/* TAG BEGIN EVNT:Size */
		statbar_autosize(TASK_WIN);
		/* TAG END EVNT:Size */
		}
		break;
	case E_CLOSE:
		/*
			Request to close (terminate) application; user operated
			"close" menu item on task or ghost window system menu, or
			operated "close" control on task or ghost window frame.
			Possible if physical task window or on X-based systems. Not
			sent if Close on File menu is issued.
		*/
		{
		/* TAG BEGIN EVNT:Close */
		if (is_quit_OK())
		{
		   xvt_app_destroy();
		}
		/* TAG END EVNT:Close */
		}
		break;
	case E_COMMAND:
		/*
			User issued command on TASK_WIN menu bar. Platform specifics: 
			Win/PM -- no MDI docs open and task-window menu bar operated; 
			X* -- no docs open and ghost window menu bar operated; 
			Mac/CH -- no docs have focus; menu bar at top of screen operated.
		*/
		{
		/* TAG BEGIN EVNT:Command */
		do_TASK_MENUBAR(xdWindow, xdEvent);
		/* TAG END EVNT:Command */
		}
		break;
	case E_FONT:
		/*
			User issued font command on window menu bar (menu bar at top of
			screen for Mac/CH).
		*/
		{
		/* TAG BEGIN EVNT:Font */
		/* TAG END EVNT:Font */
		}
		break;
	case E_TIMER:
		/*
			Timer associated with TASK_WIN went off.
		*/
		{
		/* TAG BEGIN EVNT:Timer */
		/* TAG END EVNT:Timer */
		}
		break;
	case E_QUIT:
		/*
			System shutdown. (Sent only on those platforms which
			provide this information to XVT.)
		*/
		{
		/* TAG BEGIN EVNT:Quit */
		if (xdEvent->v.query) {
			if (is_quit_OK())
					xvt_app_allow_quit();
		} else
			xvt_app_destroy();
		/* TAG END EVNT:Quit */
		}
		break;
	case E_USER:
		/*
			Application initiated.
		*/
		{
		/* TAG BEGIN EVNT:User */
		switch (xdEvent->v.user.id) {
		case -1:
		default:
			break;
		}
		/* TAG END EVNT:User */
		}
		break;
default:
	break;
}
	/* TAG BEGIN SPCL:Bottom */
	/* TAG END SPCL:Bottom */
	return 0L;
}

BOOLEAN
#if XVT_CC_PROTO
is_quit_OK(void)
#else
is_quit_OK()
#endif
{
	/* TAG BEGIN SPCL:Is_Quit_OK */
	if (xvt_dm_post_ask("Cancel", "Quit", NULL,
	             "Are you sure you wish to Quit?")!= RESP_DEFAULT)
	{
	   return (TRUE);
	}
	else
	   return (FALSE);
	/* TAG END SPCL:Is_Quit_OK */
}

void
#if XVT_CC_PROTO
xdCheckRadioButton(WINDOW xdWindow, int check, int start, int end)
#else
xdCheckRadioButton(xdWindow, check, start, end)
WINDOW xdWindow;
int check;
int start;
int end;
#endif
{
	WINDOW *radiobtns;
	int num_btns = end - start + 1;
	int i;
	radiobtns = (WINDOW *)xvt_mem_alloc(num_btns * sizeof(WINDOW));
	for (i = start; i <= end; i++) {
		radiobtns[i-start] = xvt_win_get_ctl(xdWindow, i);
	}
	xvt_ctl_check_radio_button(xvt_win_get_ctl(xdWindow, check), radiobtns, 
		num_btns);
	xvt_mem_free((char *)radiobtns);
}

XVT_HELP_INFO
#if XVT_CC_PROTO
xdGetHelpInfo(void)
#else
xdGetHelpInfo()
#endif
{
	xdOpenHelp();
	return xd_help_info;
}

static void
#if XVT_CC_PROTO
xdOpenHelp( void )
#else
xdOpenHelp()
#endif
{
	FILE_SPEC  fs;
	FL_STATUS  status;

	if (!xd_help_info)
	{
		xvt_fsys_get_default_dir( &fs.dir );
		fs.type[0] = '\0';
		fs.creator[0] = '\0';
		//xvt_str_copy( fs.name, xvt_config.base_appl_name );
		xd_help_info = xvt_help_open_helpfile( &fs, 0L );
#if XVTWS != PMWS   /* Do not look elsewhere for the help file under PM. */
		while (!xd_help_info)
		{
			status = xvt_dm_post_file_open(&fs,
				"Please Find and Open help file...");
			if (status == FL_CANCEL)
				return;
			if (!xvt_fsys_get_file_attr( &fs, XVT_FILE_ATTR_READ ))
			{
				xvt_dm_post_error(
					"Help file is unreadable, please choose another.");
				continue;
			}
			if (xvt_fsys_get_file_attr( &fs, XVT_FILE_ATTR_DIRECTORY ))
			{
				xvt_dm_post_error(
					"Invalid help file, please choose another.");
				continue;
			}
			if (status != FL_BAD)
				xd_help_info = xvt_help_open_helpfile( &fs, 0L );
			if (!xd_help_info)
				xvt_dm_post_note(
					"Invalid help file, please choose another.");
		}
#endif
	}
}

static BOOLEAN XVT_CALLCONV1
#if XVT_CC_PROTO
xdHelpHook( void*  ctx, WINDOW  win, EVENT*  ev )
#else
xdHelpHook( ctx, win, ev )
void*  ctx;
WINDOW  win;
EVENT*  ev;
#endif
{
	long  index;
	xd_HELP_ASSOC*  assoc;

	if (xd_help_info)
	{
		if (ctx)
			return !xvt_help_process_event( (XVT_HELP_INFO) ctx, win, ev );
		else
			return !xvt_help_process_event( xd_help_info, win, ev );
	}

	if (
			ev->type == E_HELP ||
			(ev->type == E_COMMAND &&
			ev->v.cmd.tag >= M_HELP &&
			ev->v.cmd.tag <= M_HELP + 12)  /* M_HELP_LAST */
	)
	{
		xdOpenHelp();
		if (!xd_help_info)
			return TRUE;

		for (index = 0L; index < xd_list_size; index++)
			if (xd_temp_assoc_list[index].container != NULL_WIN)
			{
				assoc = &xd_temp_assoc_list[index];
				xdSetHelpAssoc(
					assoc->container,
					assoc->obj_id,
					assoc->topic_id,
					assoc->obj_type );
			}

		if (xd_temp_assoc_list)
		{
			xvt_mem_free( (char *) xd_temp_assoc_list );
			xd_temp_assoc_list = (xd_HELP_ASSOC *) 0;
			xd_list_size = xd_next_slot = 0L;
		}

		return !xvt_help_process_event( xd_help_info, win, ev );
	}

	return TRUE;
}


static void
#if XVT_CC_PROTO
xdInitHelp( void )
#else
xdInitHelp()
#endif
{
	/*
	 *  temporary association table initialized on first call to
	 *  xdSetHelpAssoc()
	 */

	xvt_vobj_set_attr( NULL_WIN, ATTR_HELP_HOOK, (long) xdHelpHook );
}


static void
#if XVT_CC_PROTO
xdCleanupHelp( void )
#else
xdCleanupHelp()
#endif
{
	if (xd_temp_assoc_list)
		xvt_mem_free( (char *) xd_temp_assoc_list );
	xd_temp_assoc_list = (xd_HELP_ASSOC *) 0;
	if (xd_help_info)
		xvt_help_close_helpfile( xd_help_info );
	xd_help_info = (XVT_HELP_INFO) 0;
}


void
#if XVT_CC_PROTO
xdSetHelpAssoc(
		WINDOW  container,
		long  obj_id,
		long  topic_id,
		xd_OBJ_TYPE  obj_type )
#else
xdSetHelpAssoc( container, obj_id, topic_id, obj_type )
WINDOW  container;
long  obj_id;
long  topic_id;
xd_OBJ_TYPE  obj_type;
#endif
{
	long  index;
	WINDOW  ctl_win;

	if (!xd_help_info)
	{
		/*
		 *  If there isn't another available slot, we need to
		 *  grow the temporary association table.
		 */
		if (xd_next_slot == -1L)
		{
			xd_list_size += xd_BLOCK_SIZE;
			xd_temp_assoc_list = (xd_HELP_ASSOC *) xvt_mem_realloc(
					(char *) xd_temp_assoc_list,
					(size_t) xd_list_size * sizeof( xd_HELP_ASSOC ) );
			xd_next_slot = xd_list_size - xd_BLOCK_SIZE;
			for (index = xd_next_slot; index < xd_list_size; index++)
				xd_temp_assoc_list[index].container = NULL_WIN;
		}

		/*
		 *  Register the new association.
		 */
		xd_temp_assoc_list[xd_next_slot].container = container;
		xd_temp_assoc_list[xd_next_slot].obj_id = obj_id;
		xd_temp_assoc_list[xd_next_slot].topic_id = topic_id;
		xd_temp_assoc_list[xd_next_slot].obj_type = obj_type;

		/*
		 *  Find the next available slot.
		 */
		index = xd_next_slot + 1L;
		while (
				index < xd_list_size &&
				xd_temp_assoc_list[index].container != NULL_WIN
		)
			index++;
		if (index < xd_list_size)
		{
			xd_next_slot = index;
			return;
		}
		index = 0L;
		while (
				index < xd_next_slot &&
				xd_temp_assoc_list[index].container != NULL_WIN
		)
			index++;
		if (index < xd_next_slot)
		{
			xd_next_slot = index;
			return;
		}
		index = -1L;
	}
	else
	{
		switch( obj_type )
		{
			case xd_CNTR:
				xvt_help_set_win_assoc( xd_help_info, container, topic_id, 0L );
				break;

			case xd_CTRL:
				ctl_win = xvt_win_get_ctl( container, (int) obj_id );
				if (ctl_win != NULL_WIN)
					xvt_help_set_win_assoc( xd_help_info, ctl_win, topic_id, 0L );
				break;

			case xd_MENU:
				xvt_help_set_menu_assoc( xd_help_info, container, (MENU_TAG) obj_id, topic_id, 0L );
				break;

			default:
				break;
		}
	}
}


void
#if XVT_CC_PROTO
xdRemoveHelpAssoc( WINDOW  win )
#else
xdRemoveHelpAssoc( win )
#endif
{
	long  index;
	xd_HELP_ASSOC*  assoc;

	if (!xd_help_info)
	{
		for (index = 0L; index < xd_list_size; index++)
		{
			assoc = &xd_temp_assoc_list[index];
			if (assoc->container == win)
			{
				assoc->container = NULL_WIN;
				xd_next_slot = index;
			}
		}
	}
}
